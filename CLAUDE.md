# Geometric Solver - Claude Code Context

## Repository Overview
This is a geometric solver that uses diffusion models to solve Steiner tree problems. The system converts graph problems into 2D image representations and trains a UNet to generate optimal solutions.

## Key Components

### Data Generation
- **Two-stage approach**: First generate optimal solutions with GeoSteiner, then create training data
- **Real optimal solutions**: Uses GeoSteiner library to solve Steiner tree problems optimally
- **SteinerGraphDataset** (`data/Graphs_Steiner.py`): Loads pre-generated optimal Steiner instances
  - Creates binary image representations (128Ã—128) of graphs
  - Terminal nodes: 3-7 randomly placed circles (radius 7px), minimum 0.2 distance apart
  - Optimal Steiner trees: Generated by GeoSteiner with exact solutions
  - Edges: 2px wide lines connecting nodes in optimal tree structure
  - Uses distance transform preprocessing when `use_distance_transform=true`

### Data Generation Script (`generate_steiner_data.py`)
- **Parallel generation**: Multi-process generation of Steiner tree instances
- **GeoSteiner integration**: Uses `efst | bb` pipeline for optimal solving
- **Real constraints**: Ensures nodes don't overlap and stay within image bounds
- **Graph extraction**: Parses GeoSteiner output to extract vertices and edge connectivity
- **Output formats**: JSON instance data, raw solutions, and visualization images
- **Timeout handling**: 30-second timeout per instance to handle complex cases

### Model Architecture (`model/diffusion.py`)
- **UNet**: 2-channel input (condition + noisy target), 1-channel output
- 4 encoder/decoder levels with attention at specific locations
- Time embedding for diffusion process
- Multi-head self-attention blocks for spatial reasoning

### Training (`training/train_diffusion.py`)
- Diffusion-based training with DDIM scheduler
- Loss options: L1/L2 on noise prediction or x_0 reconstruction  
- Classifier-free guidance support (p_null parameter)
- Validation with quality/alignment metrics

### Configuration (`configs/config.yaml`)
- Current setup: 60k samples, Steiner graphs, distance transform enabled
- Training: 1000 epochs, batch size 128, AdamW optimizer
- Model: 64 base channels, 4 levels, attention at bottleneck + enc/dec layers

## Graph Representation
- **Input**: Binary mask of terminal nodes (black circles on white background)
- **Target**: Complete Steiner tree (terminals + Steiner nodes + edges)
- **Format**: 2D images with values [-1,1] where -1=graph elements, +1=background
- **Problem**: Network learns to generate optimal Steiner tree from terminal positions

## Key Scripts
- `scripts/train.py`: Main training entry point
- `scripts/sample_graphs_steiner.py`: Generate samples from trained model
- `gradio_app.py`: Web interface for interactive use

## Testing & Validation
- Quality metrics: squareness measure for generated structures
- Alignment metrics: how well solution aligns with input terminals
- Visual validation through W&B logging of samples

## Graph Extraction (`scripts/extract_steiner_graph.py`)
- **Purpose**: Extract graph structure (vertices + edges) from binary Steiner tree images
- **Algorithm**: 
  - Vertex detection: Morphological opening to isolate nodes, then connected component analysis
  - Edge detection: Check if straight line between vertex pairs is covered by foreground pixels
- **Usage**: `python scripts/extract_steiner_graph.py image.png --debug --coverage-threshold 0.7`
- **Output**: Vertex coordinates and edge list, plus NetworkX graph format

## Commands
- Data Generation: `python generate_steiner_data.py --num-instances 1000 --num-workers 8`
- Training: `python scripts/train.py` (uses Hydra config)
- Sampling: `python scripts/sample_graphs_steiner.py`  
- Graph Extraction: `python scripts/extract_steiner_graph.py image.png --debug`
- Test Extraction: `python scripts/test_graph_extraction.py`
- Web UI: `python gradio_app.py`

## Installation & Setup

### 1. **System Dependencies**
Install required build tools:
```bash
sudo apt-get update
sudo apt-get install build-essential libtool libtool-bin autotools-dev automake
```

### 2. **GeoSteiner Library**
Build GeoSteiner 5.3 for optimal Steiner tree solving:
```bash
cd geosteiner-5.3/
chmod +x configure
./configure
make
```

This creates the required binaries: `rand_points`, `efst`, `bb`, `fst2graph`, `smt`

### 3. **Python Environment**
Always use the virtual environment:
```bash
source .venv/bin/activate
pip install torch networkx opencv-python hydra-core wandb scipy matplotlib tqdm
```

### 4. **Verification**
Test GeoSteiner installation:
```bash
cd geosteiner-5.3/
./rand_points 3 | ./efst | ./bb  # Should generate and solve a 3-point Steiner tree
```

## Dependencies
- **System**: build-essential, libtool, libtool-bin, autotools-dev, automake
- **Python packages**: torch, networkx, opencv, hydra-core, wandb, scipy, matplotlib, tqdm  
- **External libraries**: GeoSteiner 5.3 (for optimal Steiner tree solving)
- **GeoSteiner binaries**: rand_points, efst, bb, fst2graph (located in `geosteiner-5.3/` directory)

## Virtual Environment
ALWAYS use the virtual environment at the `.venv` folder before running any python script (`source .venv/bin/activate`). If you see some NumPy/Torch compatibility issues - YOU ARE USING THE WRONG ENVIRONMENT!